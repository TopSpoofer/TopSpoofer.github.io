---
layout: post
title:  "类选（抢）课系统的设计、实现与优化"
date:   '2019-07-10 16:00:00'
author: 'spoofer'
categories: '笔记'
tags: '选课，高并发系统'
excerpt: 'scala akka redis mysql 死锁 高并发 actor'
keywords: 'scala akka redis mysql 死锁 高并发 actor'
---

去年底写了个高考选课系统，近排测试的同学报了个bug，是的这个bug是类似于抢购、秒杀场景的超卖，少买的bug，是非常严重的。review了代码后还是找不出bug所在，这种bug难跟踪不好调试，所以跟leader讨论后决定重构，下面说一下这个选课系统从需求到现在各个版本的设计与实现。

<!--more-->

## 需求

选课需求其实很简单，学生每次只能选一个选课计划内的一个或者多个课程，每个课程人数限制在 1 到无限大。所以选课的需求跟平时的抢购、秒杀场景还是有点区别的，抢购、秒杀很多都是针对一种商品，这种场景用户可以买一个或者多个，但不能买多种（只有一种商品），商品货物都是有库存的，所以数量有限。而选课一次可以选多个（对应多种商品）课程，每个课程限制人数都不一样，甚至是无限大的。

所以程序需要解决 "选择3个课程，第一二选上了，第三个却被抢光了" 这种问题

下面来看看各个版本的设计吧。

## 技术栈

scala + akka + redis + rabbitmq + mysql，感觉我们有点非主流哈哈哈

## 1.0 非可用版本

这个版本啥问题都解决不了，简单粗暴地用mysql事务做保证，直接插入。

伪代码如下：

```

事务开始：
    读取选课计划各种信息，判断每个课程的剩余数量

    批量删除这个学生对于这次选课的旧数据（重新选课了）
    批量(因为有多个课程)插入新选择的数据

    批量删除这个学生对于这次选课的旧统计数据
    批量插入新选择的统计数据
事务结束
```

这里说两点， 1、事务无法解决这种并发的问题（当前数据库的事务级别为rr）， 2、并发条件下，同一事务内批量插入、删除（更新）一个表的数据（都首先命中非主键索引），妥妥的死锁了。怎么说呢，这个版本不是我写的，不要抽我就好。这个设计体现了开发人员对数据库知识的缺乏、对这种类抢购业务系统设计经验的缺乏，对等水平大三学生吧。

## 2.0 版本

这个版本引入了redis与rabbitmq来解决‘抢’的问题。redis做缓存、rabbitmq用来削峰，但引入了这些中间件后，一致性的问题就需要考虑了，对于这个选课的系统没有必要做到强一致性，所以选择了最终一致性。

在继续下面的内容前有必要先介绍一下akka， akka比较核心的一个概念是Actor模型，有了这个模型，我们不用担心多线程、并发的问题，akka可以很好地为什么解决这部分的问题。试想一下，这个选课系统部署在多实例的生产环境，这种类抢购的功能是不是要先实现一个分布式锁？可能市面上有这样的开源库，但想想都累，看着如下的代码：

```
引入某个库

get lock
    do something。。。。
unlock
```
累吗？ 刀都选不对，还怎么劈友？加班吧！


利用akka的sharding功能，将每个选课计划用一个actor来代表，每个选课actor集群内有且只有一个实例。每个actor内串行处理学生的选课请求。每个选课actor间逻辑互不干扰。

![2.0架构图](http://www.spoofer.top/assets/images/2019/2.0.png)

redis 缓存了每个课程剩余数量，在选课计划actor内做所有逻辑判断，成功选上课就更新redis，并且异步写数据库。

需要注意的是，一次请求可能选上多节课，所以需要多次更新redis（这个版本没有用到redis lua脚本功能），所以做了很多失败回滚的操作。

对于mq订阅者，这里设计每个消息的消费都是幂等的，所以mq订阅者带上了重放功能，即使是这样也无法100%保证系统的最终一致性，考虑一种情况，用户进行了选课，请求成功，并且已经进入mq正在消费，这个时候mysql端的网络挂了，消息未被成功消费，消息进行重放，这个时候用户进行了重新选课，新的请求在旧消息重放进入队列前先进入队列了，数据库网络恢复，新消息被消费，旧消息接着被消费，最终不一致！这种问题如何解决？继续往下看吧。

这个版本相比前一个版本有了很大的改进，但入库的代码还是用原来的那一套，死锁依然存在。优点：并发性高了（对于单个选课计划来说，没有并发的概念）， 入库和选课操作做了分离，对数据库做了保护。缺点，选课actor维护了太多的逻辑，包括各种条件判断、失败回滚等，造成bug出现。

因为多个课程需要更新redis和学生所选的课程列表都要更新redis，这样一次选课逻辑下来平均10来个毫秒吧，10ms看起来不慢其实已经很慢了，因为一个选课计划内只能串行处理请求，所以对于每个选课计划其 rps < 100！对于大一点的学校来说，一个年级一般1500人吧，这样处理完全部人需要15s！！（这是假设情况下，一般一个选课都是一个年级来选的）


## 3.0 版本

这个版本对2.0版本的选课actor做了拆解，拆分为3个actor： 选课actor、课程actor、学生actor

![拆解后示意图](http://www.spoofer.top/assets/images/2019/3.0.1.png)


1、选课actor
控制着每个请求串行处理、对请求做前期检查，例如提交的课程是否符合要求、学生是否有权限进行此次选课等。

2、课程actor（一个选课计划内，一门课程一个actor）
这个版本里课程不再是一个id与一个数字了，而是一个actor。这个actor维护对应课程的数量、提供check和commit指令来检查和修改数量。这个actor并没有直接修改redsi的功能，如果这个功能写在这里将会导致很多的问题，例如有一门课选择失败了，就要回滚其他课程。对于每个选课请求这个actro的check和commit指令都是串行的，这个逻辑由学生actor来维护。

3、学生actor（一个选课计划内，一个学生一个actor）
负责维护每个学生的信息，并且进行选课操作，选课操作包括先向各个课程actor发送check指令，如果都成功，更新redis，这里更新使用redis的lua脚本一次更新多个课程的数量和设置学生所选课程列表，并且使用hincr的指令而不是直接设置数量（2.0版本就是直接设置数量的）成功后再发送选课事件到mq，并且发送commit指令给课程actor进行数量更新。如果check失败或者更新redis失败就直接返回对应的失败原因。学生actor完成选课逻辑，通知选课计划actor。如果mq发送失败，做详细日志后续人工补偿。

![拆解后示意图](/assets/images/2019/3.0.2.png)

这个版本相对于2.0版本来说没有太大的性能提升（反而慢了），但是因为经过拆分了3种actor，使每种actor功能都清晰、单一、代码组织变得非常简单，没有复杂的逻辑。到这里，一开始的那种超卖超买的bug应该是修复了。

这个版本，因为使用redis的lua脚本进行提交，脚本要做的事情太多使整个redis更新操作变得非常慢，15-20 ms，我这边的情况是这样的，数量更新（包括hincr 1 或者 hincr -1, -1的情况是重新选课产生的）和设置学生所选课程列表在同一个lua脚本中进行，后面发现啊，这个hset是占了非常大的一部分时间，所以在后面的版本把这个更新抽取出来，分开操作了。

这里出现的check、commit，是类似于两阶段提交的做法，学生actor是协调者，各个课程actor是参与者，学生actor协调各个课程的actor进行表决（check），如果通过就提交执行（commit）。

这个版本开始进行了压测，终于发现了db模块是有死锁bug的。

总结一下这个版本：
优点：
1、每种actor职责单一，代码逻辑清晰
2、redis采用lua脚本提交，解决了多次提交的失败带来的回滚工作。

缺点：
1、lua脚本处理的指令多，速度太慢
2、死锁bug


## 4.0 版本

这个版本是针对3.0出现的问题进行改进的。既然数据库事务提交会死锁，那撤掉事务吧（经过查看mysql的死锁日志所做的决定），但是撤掉事务后如何保证数据的一致性是个难点，同时这部分的重构需要解决2.0提到的数据库挂掉时的情况。redis慢，那就把lua脚本简化，数量增减和学生课程列表的更新分开做，同时这部分的功能不再安排在学生actor来处理，单独一个更新课程数量的actor来处理。

数据库部分伪代码：
```
future：
    删除旧选项
    插入新选项
future结束

future：
    删除旧统计数据
    插入新统计数据
future结束

两个future异步执行
```

![4.0架构图](http://www.spoofer.top/assets/images/2019/4.0.png)

先来解决mysql入库的问题，通过失败重放，其实解决了绝大部分问题，包括撤掉事务后的问题，但是mysql那边网络挂掉后产生的问题，需要引入一个叫版本（version）的概念来解决，获取数据只获取版本最新的就可以了。这样甚至删除的操作都不需要有了。

对于负责redis更新的actor，第一眼好像实现起来很简单，但内部其实要考虑的东西很多，同样面临redis端网络挂掉的情况，如何保证最终一致性，这里的消息同样是引入version的概念，并且优先处理失败的消息。

做完这些优化后，一个选课逻辑由15ms降到了2个ms这样子，一个量级的提升吧。而且mysql的入库同样可以并发进行了。

## 5.0版本 

这个版本处于yy阶段，选课计划不需要控制串行了，这个串行的操作推到课程actor来维护。但最终还是没有采用这种架构，可以思考一下为啥。
